---
title: 28Immutability模式
tags:
description:
---
解决并发问题最简单方法：只读
上升到解决并发问题的设计模式：不变性（Immutability）模式
不变性，简单讲，就是对象创建之后，状态不再发生变化

# 实现不变模式
类、方法、属性设置成final

String和Long、Integer、Double等基础类型的包装类都具备不可变性，这些对象的线程安全性都靠不可变性来保证

# 不可变性的类，提供修改功能
具备不可变性的类，需要提供类似修改的功能：创建一个新的不可变对象
如String.replace方法，String字符替换操作，没有修改源字符串，而是组合新字符串返回

# 避免创建重复对象：享元模式
Long、Integer、Short、Byte等基本数据类型的包装类用到了享元模式，减少创建对象的数量，减少内存占用

享元模式本质：对象池
Long内部维护了一个静态的对象池，仅缓存了[-128,127]，对象池在JVM启动的时候就创建好了
Long对象的状态有264种,太多不宜全部缓存，[-128,127]利用率最高

基本所有的基础类型应用享元模式，不适合作为锁对象，因为看上去私有的锁，其实是共有的

# Immutability模式注意事项
- 属性声明为final并不一定保证不可变
- 不可变对象需要正确发布

不可变对象线程安全，不意味着引用不可变对象的对象就是线程安全的
```
//Foo线程安全
final class Foo{
  final int age=0;
  final int name="abc";
}
//Bar线程不安全
class Bar {
  Foo foo;
  void setFoo(Foo f){
    this.foo=f;
  }
}
```

# 总结
具备不变性的对象，只有一种状态，状态由对象内部所有的不变属性共同决定
无状态对象内部没有属性，只有方法；还有无状态的服务、无状态的协议等。
多线程领域，无状态没有线程安全问题，不需处理线程同步，性能自然好
分布式领域，无状态可无限水平扩展，性能问题不会出现在无状态节点























