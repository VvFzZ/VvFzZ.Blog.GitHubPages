---
title: 14并发
date: 2024-05-09 21:39:21
tags: 
    - JAVA
    - 并发
description: 中断线程、线程状态
comments: true
---
```
public interface Runnable
{
    void run()；
}

Runnable r =（）->{ task code };
Thread t=new Thread(r);
t.start();//直接调用run方法不会启动新线程
```
## 中断线程
线程中断是为了引起线程的注意，不一定要结束线程。重要线程可处理异常后，继续执行。

`interrupt()`调用后，线程中断状态为true。
当线程被阻塞（这里阻塞是指调用sleep或wait）时调用interrupt方法，阻塞会被Interrupted Exception中断。

`islnterrupted()` 检查是否被中断
`islnterrupted()` 检测当前的线程是否被中断
`static boolean interrupted()` 检测当前的线程是否被中断,且中断状态重置为false

```
//错误做法
void mySubTask()
{
    try{sleep(delay);}
    catch(InterruptedException e){ }//Don'tignore!
}
//改进1

void mySubTask()
{
    try{sleep(delay);}
    catch(InterruptedException e)
    {Thread.currentThread().interrupt();}//设置中断，调用者可以对其进行检测
}
//改进2
void mySubTask () throws InterruptedException//抛出异常，调用者可以捕获中断异常
{
    ...
    sleep(delay);
    ...
}
```
## 线程状态
- new 新创建
- Runable 可运行
- Blocked 被阻塞
- Waiting 等待
- Timed waiting 计时等待
- Terminated 被终止

### 新创建线程
new操作符创建了线程，未开始运行。

### 可运行线程
调用start方法，线程处于runnable状态
可运行的线桿可能正在运行也可能没有运行，取决于操作系统给线程提供运行的时间。
抢占式调度，一个时间片用完，操作系统剥夺线程运行权，选择优先级高的线程执行。

### 被阻塞线程和等待线程
- Blocking 线程1试图获取一个锁（非javiutiUoncurrent库中的锁），此锁被其他线程占有，此时线程1进入阻塞状态。
- Waiting 当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。（调用Object.wait方法或Thread.join方法，或者是等待java,util.concurrent库中的Lock或Condition时）
- Time waiting 带有超时参数的方法调用时，Thread.sleep和Object.wait、Thread.join、Lock,tryLock以及Condition.await的计时版

### 被终止的线程
- run方法结束，正常退出
- 没有捕获的异常终止了run方法，意外死亡

## 线程属性

线程优先级、守护线程、线程组以及处理未捕获异常的处理器
### 线程优先级
`setPriority()`
`static void yield()`当前执行线程处于让步状态。如果有其他同优先级或跟高优先级的可运行线程，那么这些线程接下来会被调度。
`MIN_PRIORITY` 1 , `MAX_PRIORITY` 10 , `NORM_PRIORITY` 5
如果有几个高优先级的线程没有进入非活动状态，低优先级的线程可能永远也不能执行。

### 守护线程
唯一用途：为其他线程提供服务，只剩下守护线程时
守护线程任何时候甚至在一个操作的中间发生中断，不应访问固有资源（文件、数据库）。
调用`t.setDaemon(true);`将线程转换为守护线程(线程启动之前调用)

### 未捕获异常处理器
线程的run方法不能抛出受查异常，非受査异常会导致线程终止。
不需要任何catch子句来处理可以被传播的异常，线程死亡之前，异常被传递到一个用于未捕获异常的处理器。

异常处理器必须实现Thread.UncaughtExceptionHandler接口
interface UncaughtExceptionHandler{
    void uncaughtException(Threadt,Throwable e)
}

安装异常处理器
1. setUncaughtExceptionHandler
2. Thread类的静态方法`setDefaultUncaughtExceptionHandler`为所有线程安装一个默认的处理器

如果不为独立的线程安装处理器，此时的处理器就是该线程的ThreadGroup对象,ThreadGroup类实现`Thread.UncaughtExceptionHandler`接口。它的uncaughtException方法做如下操作：
1. 如有父线程组，那么父线程组的uncaughtException方法被调用。
2. 否则，调用`Thread.getDefaultExceptionHandler` 获取默认处理器，非空则调用此默认处理器
3. 否则，如果Throwable是ThreadDeath的一个实例，什么都不做。
4. 否则，线程的名字以及Throwable的栈轨迹被输出到System.err上。

## 同步

### 锁对象
两种机制
- synchronized关键字
- ReentrantLock类
```
ReentrantLock lock = new ReentrantLock();
lock.lock();
try {
    //do something
}finally {
    lock.unlock();
}
```

```
java.util.concurrent.locks.Lock5.0
void lock()
void unlock()

java,util.concurrent.locks.ReentrantLock5.0
ReentrantLock()
ReentrantLock(boo1ean fair)构建一个带有公平策略的锁。一个公平锁偏爱等待时间最长的线程。但这一公平的保证将大大降低性能。所以，默认情况下，锁没有被强制为公平的。
```
注：<small>
*听起来公平锁更合理一些，但是使用公平锁比使用常规锁要慢很多。只有当你确实了解自己要做什么并且对于你要解决的问题有一个特定的理由必须使用公平锁的时候，才可以使用公平锁。即使使用公平锁，也无法确保线程调度器是公平的。如果线程调度器选择忽略一个线程，而该线程为了这个锁已经等待了很长时间，那么就没有机会公平地处理这个锁了。*</small>

### 条件对象
使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程
```
class Bank
{
    private Condition sufficientFunds;
    publicBank()
    {
        sufficientFunds = bankLock.newCondition();//条件对象
    }

    publicvoidtransfer(intfrom,intto,intamount)
    {
        bankLock.lock()；
        try {
            while(accounts[from]<amount)
                sufficientFunds.await()；//余额不足，阻塞等待 并放弃锁，进入等待队列，等待其他线程调用signalALl或signal
            //transferfunds 
            sufficientFunds.signalAll()；//
        }
        finally{
            bankLock.unlock();
        }
    }
}
```

`signalAll() `重新激活因为这一条件而等待的所有线程,线程从等待集当中移出（解除阻塞），再次成为可运行的，获取到锁后继续执行。
`signal()`随机解除等待集中某个线程的阻塞状态

### synchronized

```
public synchronized void method()
{
    //methodbody
}

//等价于

public void method()
{
    this.intrinsidock.1ock();
    try
    {
        //methodbody
    }
    finally{this.intrinsicLock.unlock();}
}
```

条件阻塞举例
```
class Bank
{
    public synchronized void func1() throws InterruptedException{
        if(condition){
            wait()
        }
        notifyAll();
    }
}
```
静态synchronized方法将锁住整个类

### 同步阻塞

synchronized(obj)//this is the syntax for a synchronizedb lock
{
    
    //critical section
}

### Volatile域
volatile关键字为实例域的同步访问提供了一种免锁机制
声明一个域为volatile，编译器和虚拟机就知道该域可能被另一个线程并发更新
- 内存可见
- 禁止指令重排 （volatile变量的写操作，保证是在读操作之前完成）
- 赋值原子性 

应用：
- 多线程标志位
- CAS
### final变量
`final Map<String,Double> accounts = new HashKap<>()；`
其他线程在构造函数完成构造后才看到accounts变量。
如果不使用final，不能保证其他线程看到的是accounts更新后的值，它们可能看到null,而不是新构造的HashMap

### 原子性
`java.util.concurrent.atomic`包中有很多类使用了很高效的机器级指令来保证操作的原子性。
如：`Atomiclnteger.incrementAndGet`、`Atomiclnteger.decrementAndGet` 自增自减
`incrementAndGet` 获得值、增1并设置然后生成新值的操作不会中断。



如果有大量线程要访问相同的原子值，性能会大幅下降，因为乐观更新需要太多次重试。
JavaSE8提供了`LongAdder`和`LongAccumulator`类来解决这个问题。
`LongAdder`包括多个变量（加数），其总和为当前值。可以有多个线程更新不同的加数，线程个数增加时会自动提供新的加数。通常情况下，**只有当所有工作都完成之后才需要总和的值**，对于这种情况，这种方法会很高效。性能会有显著的提升。
```
final LongAdder adder=new LongAdder()；
    for(...)
        pool.submit(()->{
            while(...){
                if(...) adder.increment();//increment 自增1  add(l) 增加任意值
            }
        });
long total=adder.sum();
```

`LongAccumulator`将这种思想推广到任意的累加操作
```
LongAccumulator adder=new LongAccumulator(Long::sum,0); //可选择不同的操作，且满足结合律和交换律。
//Insomethread...
adder.accumulate(value);
```

### 死锁

### 线程局部变量
为每个线程构造一个实例：
`public static final ThreadLocal<SimpleDateFormat> dateFormat =ThreadLocal.withInitial(()->new SimpleDateFormat("yyyy-MM-dd"));`

java.util.Rand0m类是线程安全的,但如果多线程等待一个随机数生成器，很低效。
可以使用ThreadLocal辅助类为各个线程提供一个单独的生成器，还可以使用Java提供的一个便利类：
`ThreadLocalRandom`,`ThreadLocalRandom.current()`调用会返回特定于当前线程的Random类实例


### 锁测试与超时

```
if(myLock.tryLock())
{
    //now the thread owns the lock
    try{...}
    finally{myLock.unlock();}
}
else
    //do something else
```
### 读/写锁

```
private ReentrantReadWriteLock rwl=new ReentrantReadWriteLock();
private Lock readLock=rwl.readLock();
private Lock writeLock=rwl.writeLock();

public double getTotalBalance()
{
    readLock.lock()；//多线程可冲入读锁，但排斥写锁
    try{...}
    finally{readLock.unlock();}
}

public void transfer(...)
{
    writeLock.lock();//排斥其他读锁和写锁
    try{...}
    finally{writeLock.unlock();}
}
```
### 为什么弃用stop和suspend方法
stop:当线程要终止另一个线程时，无法知道什么时候调用stop方法是安全的，什么时候导致对象被破坏。因此，该方法被弃用了。在希望停止线程的时候应该中断线程，被中断的线程会在安全的时候停止。
suspend:容易引起死锁，被挂起的线程等着被恢复，而将其挂起的线程等待获得锁。

## 阻塞队列
当试图向队列添加元素而队列已满，或是想从队列移出元素而队列为空的时候，阻塞队列（blockingqueue)导致线程阻塞。

put，take 满或空时阻塞
add，remove，element 空时异常
offer，poll(移除返回)，peek(只返回) 空时 返回false，null，null

java.util.concurrent包提供了阻塞队列的几个变种：
- LinkedBlockingQueue 容量无上界，也可选择最大容量 LinkedBlockingDeque 双端队列版本
- ArrayBlockingQueue 构造时制定容量，可设置公平性
- PriorityBlockingQueue 带优先级的队列，而不是先进先出队列。按照它们的优先级顺序被移出，容量无上限
- DelayQueue
```
interface Delayed extends Comparable<Delayed>
{
    long getDelay(TimeUnitunit); //返回对象的残留延迟,负值表示延迟结束，可移除
}
```
- LinkedTransferQue implements TranSferQueue 允许生产者线程等待，直到消费者准备就绪可以接收一个元素。 q.transfer(item); 阻塞直到另一个线程将元素（item）删除。


## 线程安全的集合
### 高效的映射、集和队列
java.util.concurrent包提供了映射、有序集和队列的高效实现：
- `ConcurrentHashMap` 
- `ConcurrentSkipListMap` key有序，跳表实现，非并发使用`TreeMap`，低并发可使用包装`TreeMap`的`Collections.synchronizedSortedMap`，高并发使用`ConcurrentSkipListMap`
- `ConcurrentSkipListSet` 有序，基于SkipList的集合
- `ConcurrentLinkedQueue` 一个基于链接节点的无界线程安全队列

JavaSE8引入了一个`mappingCount`方法可以把大小作为long返回（元素过多，int范围小）。

返回弱一致性（weaklyconsistent)的迭代器。迭代器不一定能反映出它们被构造之后的所有的修改，但是，它们不会将同一个值返回两次，也不会拋出`ConcurrentModificationException`异常。
`ConcurrentHashMap` 默认支持16个写线程并发执行，多余的将阻塞。

在JavaSE8中，并发散列映射将桶组织为树，防止因大量相同散列码的值而降低性能
### 映射条目的原子更新

```
map.putlfAbsent(word,newLongAdder())；// 返回oldValue
map.get(word).increment();


map.compute(word,(k,v)->v = null ? 1 : v+1);//调用compute方法时可以提供一个键和一个计算新值的函数。

map.merge(word, 1L ,(existingValue,newValue) -> existingValue + newValue); 这个方法有一个参数表示键不存在时使用的初始值。否则，就会调用你提供的函数来结合原值与初始值。
```
传入compute或merge的函数返回null,将从映射中删除现有的条目
注：*使用compute或merge时，提供的函数不能做太多工作。因为函数运行时，可能会阻塞对映射的其他更新。且这个函数也不能更新映射的其他部分。*

### 对并发散列映射的批操作



